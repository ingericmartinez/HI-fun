<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Popper</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bungee&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a237e; /* Azul oscuro */
            font-family: 'Bungee', cursive;
            color: white;
            text-align: center;
        }

        .game-container {
            position: relative;
            background: #283593; /* Azul medio */
            padding: 20px;
            border-radius: 25px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2), 0 6px 6px rgba(0,0,0,0.23), inset 0 0 10px rgba(0,0,0,0.5);
        }
        
        #game-canvas {
            background-color: #3f51b5; /* Azul índigo */
            border-radius: 15px;
            border: 5px solid #1a237e;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.4);
        }

        .game-ui {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            font-size: 2em;
            text-shadow: 3px 3px 0px #0d1241;
        }

        #score {
            color: #ffeb3b; /* Amarillo */
        }
        
        #next-bubble-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #next-bubble-preview {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 0 10px white;
        }

        /* --- Estilos para los Overlays --- */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            display: none; /* Oculto por defecto */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 3em;
            text-shadow: 4px 4px 0px #000;
            border-radius: 25px;
        }
        
        .overlay.visible {
            display: flex;
        }
        
        .overlay h1 {
            font-size: 1.5em;
            margin-bottom: 20px;
        }
        
        .overlay-button {
            font-family: 'Bungee', cursive;
            font-size: 0.5em;
            margin-top: 20px;
            padding: 15px 30px;
            border: none;
            border-radius: 15px;
            background-color: #ffc107; /* Ámbar */
            color: #1a237e;
            cursor: pointer;
            box-shadow: 0 5px 0 #e65100; /* Naranja oscuro */
            transition: all 0.1s ease-in-out;
        }
        
        .overlay-button:active {
            transform: translateY(3px);
            box-shadow: 0 2px 0 #e65100;
        }
        
        #final-score-container {
            font-size: 0.6em;
            margin-top: 10px;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <div class="game-ui">
            <div>Puntuación: <span id="score">0</span></div>
            <div id="next-bubble-container">
                <span>Sig:</span>
                <div id="next-bubble-preview"></div>
            </div>
        </div>
        <canvas id="game-canvas" width="600" height="700"></canvas>
        
        <!-- Banner de Juego Terminado -->
        <div id="game-over-overlay" class="overlay">
            <div>¡JUEGO TERMINADO!</div>
            <div id="final-score-container">Tu Puntuación: <span id="final-score">0</span></div>
            <button id="restart-button" class="overlay-button">Reiniciar</button>
        </div>
        
        <!-- Pantalla de Inicio -->
        <div id="start-game-overlay" class="overlay visible">
            <h1>Bubble Popper</h1>
            <button id="start-button" class="overlay-button">Iniciar Juego</button>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const nextBubblePreviewEl = document.getElementById('next-bubble-preview');
        
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const restartButton = document.getElementById('restart-button');
        const finalScoreEl = document.getElementById('final-score');
        const startGameOverlay = document.getElementById('start-game-overlay');
        const startButton = document.getElementById('start-button');

        const COLS = 10;
        const ROWS = 12;
        const BUBBLE_RADIUS = canvas.width / (COLS * 2);
        const BUBBLE_DIAMETER = BUBBLE_RADIUS * 2;
        const COLORS = ['#e53935', '#1e88e5', '#43a047', '#fdd835', '#8e24aa', '#fb8c00'];
        const SHOOT_SPEED = 15;
        const MIN_MATCH = 3;

        let grid = [];
        let shooterBubble;
        let nextBubble;
        let projectile = null;
        let score = 0;
        let isGameOver = false;
        let isGameRunning = false;
        let mouse = { x: canvas.width / 2, y: canvas.height - BUBBLE_RADIUS };
        
        // ===== NUEVO: Variable para el contexto de audio =====
        let audioCtx;

        class Bubble {
            constructor(row, col, color) {
                this.row = row;
                this.col = col;
                this.color = color;
                this.radius = BUBBLE_RADIUS;
                this.updatePosition();
            }

            updatePosition() {
                this.x = this.col * BUBBLE_DIAMETER + (this.row % 2 === 1 ? BUBBLE_RADIUS : 0) + BUBBLE_RADIUS;
                this.y = this.row * (BUBBLE_DIAMETER - 8) + BUBBLE_RADIUS;
            }

            draw() {
                ctx.beginPath();
                const gradient = ctx.createRadialGradient(this.x - 5, this.y - 5, 1, this.x, this.y, this.radius);
                gradient.addColorStop(0, 'white');
                gradient.addColorStop(0.7, this.color);
                gradient.addColorStop(1, this.color);
                
                ctx.fillStyle = gradient;
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.closePath();
            }
        }
        
        class Projectile extends Bubble {
            constructor(x, y, color, angle) {
                super(-1, -1, color);
                this.x = x;
                this.y = y;
                this.dx = Math.cos(angle) * SHOOT_SPEED;
                this.dy = Math.sin(angle) * SHOOT_SPEED;
            }

            move() {
                this.x += this.dx;
                this.y += this.dy;

                if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
                    this.dx *= -1;
                }
            }
        }

        function init() {
            isGameOver = false;
            isGameRunning = true;
            score = 0;
            projectile = null;
            updateScore();
            gameOverOverlay.classList.remove('visible');
            
            grid = [];
            for (let r = 0; r < 5; r++) {
                grid[r] = [];
                for (let c = 0; c < COLS - (r % 2); c++) {
                    grid[r][c] = new Bubble(r, c, getRandomColor());
                }
            }
            
            prepareShooter();
            gameLoop();
        }

        function prepareShooter() {
            shooterBubble = new Bubble(-1, -1, getRandomColor());
            shooterBubble.x = canvas.width / 2;
            shooterBubble.y = canvas.height - BUBBLE_RADIUS;
            
            nextBubble = new Bubble(-1, -1, getRandomColor());
            nextBubblePreviewEl.style.backgroundColor = nextBubble.color;
        }

        function getRandomColor() {
            return COLORS[Math.floor(Math.random() * COLORS.length)];
        }

        function gameLoop() {
            if (isGameOver) {
                isGameRunning = false;
                return;
            }
            
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function update() {
            if (!projectile) return;
            
            projectile.move();

            if (projectile.y - projectile.radius < 0) {
                snapProjectile();
                return;
            }

            for (let r = 0; r < grid.length; r++) {
                if (!grid[r]) continue;
                for (let c = 0; c < grid[r].length; c++) {
                    const bubble = grid[r][c];
                    if (bubble) {
                        const dist = Math.hypot(projectile.x - bubble.x, projectile.y - bubble.y);
                        if (dist < BUBBLE_DIAMETER) {
                            snapProjectile();
                            return;
                        }
                    }
                }
            }
        }
        
        function snapProjectile() {
            const newBubble = snapToGrid(projectile);
            projectile = null;
            
            if (newBubble) {
                if (!grid[newBubble.row]) grid[newBubble.row] = [];
                grid[newBubble.row][newBubble.col] = newBubble;
                
                const matches = findMatches(newBubble);
                
                if (matches.length >= MIN_MATCH) {
                    popBubbles(matches);
                    const floating = findFloatingBubbles();
                    if (floating.length > 0) {
                        popBubbles(floating, true);
                    }
                }
                
                checkGameOver();
                if (!isGameOver) {
                    shooterBubble = nextBubble;
                    shooterBubble.x = canvas.width / 2;
                    shooterBubble.y = canvas.height - BUBBLE_RADIUS;
                    
                    nextBubble = new Bubble(-1, -1, getRandomColor());
                    nextBubblePreviewEl.style.backgroundColor = nextBubble.color;
                }
            }
        }

        function snapToGrid(bubble) {
            let bestFit = { dist: Infinity, row: -1, col: -1 };
            const roughRow = Math.floor((bubble.y - BUBBLE_RADIUS) / (BUBBLE_DIAMETER - 8));
            const startRow = Math.max(0, roughRow - 2);
            const endRow = Math.min(ROWS, roughRow + 2);

            for (let r = startRow; r <= endRow; r++) {
                 if(!grid[r]) grid[r] = [];
                 for (let c = 0; c < COLS - (r % 2); c++) {
                    if (grid[r][c]) continue;
                    const cellX = c * BUBBLE_DIAMETER + (r % 2 === 1 ? BUBBLE_RADIUS : 0) + BUBBLE_RADIUS;
                    const cellY = r * (BUBBLE_DIAMETER - 8) + BUBBLE_RADIUS;
                    const dist = Math.hypot(bubble.x - cellX, bubble.y - cellY);
                    if (dist < bestFit.dist) {
                        bestFit = { dist, row: r, col: c };
                    }
                 }
            }
            
            if (bestFit.row !== -1) {
                return new Bubble(bestFit.row, bestFit.col, bubble.color);
            }
            return null;
        }
        
        function findMatches(startBubble) {
            const toCheck = [startBubble];
            const checked = new Set([`${startBubble.row},${startBubble.col}`]);
            const matches = [startBubble];

            while (toCheck.length > 0) {
                const current = toCheck.pop();
                const neighbors = getNeighbors(current);
                for (const neighbor of neighbors) {
                    const key = `${neighbor.row},${neighbor.col}`;
                    if (!checked.has(key) && neighbor.color === startBubble.color) {
                        checked.add(key);
                        toCheck.push(neighbor);
                        matches.push(neighbor);
                    }
                }
            }
            return matches;
        }
        
        function getNeighbors(bubble) {
            const neighbors = [];
            const directions = [ [0, -1], [0, 1], [-1, 0], [1, 0] ];
            const diagonalOffset = bubble.row % 2 === 0 ? -1 : 1;
            directions.push([-1, diagonalOffset], [1, diagonalOffset]);
            
            for (const [dr, dc] of directions) {
                const r = bubble.row + dr;
                const c = bubble.col + dc;
                if (grid[r] && grid[r][c]) {
                    neighbors.push(grid[r][c]);
                }
            }
            return neighbors;
        }

        function popBubbles(bubblesToPop, isFloating = false) {
            // ===== NUEVO: Reproducir sonido de explosión =====
            playSound('pop');
            bubblesToPop.forEach(bubble => {
                grid[bubble.row][bubble.col] = null;
            });
            score += bubblesToPop.length * (isFloating ? 20 : 10);
            updateScore();
        }
        
        function findFloatingBubbles() {
            const connected = new Set();
            const toCheck = [];

            if (grid[0]) {
                for (let c = 0; c < grid[0].length; c++) {
                    if (grid[0][c]) {
                        toCheck.push(grid[0][c]);
                        connected.add(`${0},${c}`);
                    }
                }
            }

            while (toCheck.length > 0) {
                const current = toCheck.pop();
                const neighbors = getNeighbors(current);
                for (const neighbor of neighbors) {
                    const key = `${neighbor.row},${neighbor.col}`;
                    if (!connected.has(key)) {
                        connected.add(key);
                        toCheck.push(neighbor);
                    }
                }
            }
            
            const floating = [];
            for (let r = 0; r < grid.length; r++) {
                if (!grid[r]) continue;
                for (let c = 0; c < grid[r].length; c++) {
                    if (grid[r][c] && !connected.has(`${r},${c}`)) {
                        floating.push(grid[r][c]);
                    }
                }
            }
            return floating;
        }
        
        function checkGameOver() {
            const lastRow = grid[ROWS - 1];
            if (lastRow) {
                for (let c = 0; c < lastRow.length; c++) {
                    if (lastRow[c]) {
                        isGameOver = true;
                        finalScoreEl.textContent = score;
                        gameOverOverlay.classList.add('visible');
                        break;
                    }
                }
            }
        }

        function updateScore() {
            scoreEl.textContent = score;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            grid.forEach(row => {
                if (row) row.forEach(bubble => bubble && bubble.draw());
            });
            if (projectile) projectile.draw();
            if (!isGameOver && shooterBubble) {
                shooterBubble.draw();
                drawAimLine();
            }
        }

        function drawAimLine() {
            const angle = Math.atan2(mouse.y - shooterBubble.y, mouse.x - shooterBubble.x);
            if (angle > -0.1 || angle < -Math.PI + 0.1) return;
            ctx.beginPath();
            ctx.moveTo(shooterBubble.x, shooterBubble.y);
            ctx.lineTo(shooterBubble.x + Math.cos(angle) * 1000, shooterBubble.y + Math.sin(angle) * 1000);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 3;
            ctx.stroke();
        }
        
        // ===== NUEVO: Función para generar y reproducir sonidos =====
        function playSound(type) {
            if (!audioCtx) return; // No hacer nada si el audio no está inicializado
            
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);

            if (type === 'shoot') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
                oscillator.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'pop') {
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(220, audioCtx.currentTime + 0.15);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
                oscillator.stop(audioCtx.currentTime + 0.15);
            }
            
            oscillator.start(audioCtx.currentTime);
        }

        // --- Event Listeners ---
        canvas.addEventListener('mousemove', (e) => {
            if (!isGameRunning) return;
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });

        canvas.addEventListener('click', () => {
            if (isGameOver || projectile || !shooterBubble || !isGameRunning) return;
            const angle = Math.atan2(mouse.y - shooterBubble.y, mouse.x - shooterBubble.x);
            if (angle > -0.1 || angle < -Math.PI + 0.1) return;
            
            // ===== NUEVO: Reproducir sonido de disparo =====
            playSound('shoot');
            
            projectile = new Projectile(shooterBubble.x, shooterBubble.y, shooterBubble.color, angle);
            shooterBubble = null;
        });
        
        restartButton.addEventListener('click', init);
        
        startButton.addEventListener('click', () => {
            // ===== NUEVO: Inicializar el AudioContext con la interacción del usuario =====
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            startGameOverlay.classList.remove('visible');
            init();
        });
    });
    </script>

</body>
</html>
